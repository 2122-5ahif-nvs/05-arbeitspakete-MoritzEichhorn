= Arbeitspakete Dokumentation
Moritz Eichhorn
1.0.0, 2021-12-09
ifndef::imagesdir[:imagesdir: images]
//:toc-placement!:  // prevents the generation of the doc at this position, so it can be printed afterwards
:sourcedir: ../src/main/java
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc: left

//Need this blank line after ifdef, don't know why...
ifdef::backend-html5[]

// print the toc here (not at the default position)
//toc::

== Websockets
=== Allgemeines
Bei Websockets besteht zwischen dem Server und dem Client eine
bidirektionale Verbindung. So kann auch der Server dem Client
Informationen zukommenlassen.

Beispiele:

* Chat
* Live-Sport-Ticker
* Onlinespiele

=== Implementierung
* Extension einfügen:

[source]
----
./mvnw quarkus:add-extension -Dextensions="websockets"
----

* Neuen Serverendpoint Erstellen:

[source,java]
----
@ServerEndpoint("/chat/{username}")
@ApplicationScoped
public class ChatSocket {
}
----

* Zur Verwaltung der Sessions eine Map erstellen:

[source,java]
----
Map<String, Session> sessions = new ConcurrentHashMap<>();
----

* Methoden für den Umgang mit Websockets in `ChatSocket` einfügen:

[source,java]
----
@OnOpen
public void onOpen(Session session, @PathParam("username") String username) {
    sessions.put(username, session);
}

@OnClose
public void onClose(Session session, @PathParam("username") String username) {
    sessions.remove(username);
    broadcast("User " + username + " left");
}

@OnError
public void onError(Session session, @PathParam("username") String username, Throwable throwable) {
    sessions.remove(username);
    broadcast("User " + username + " left on error: " + throwable);
}

@OnMessage
public void onMessage(String message, @PathParam("username") String username) {
    if (message.equalsIgnoreCase("_ready_")) {
        broadcast("User " + username + " joined");
    } else {
        broadcast(">> " + username + ": " + message);
    }
}

private void broadcast(String message) {
    sessions.values().forEach(s -> {
        s.getAsyncRemote().sendObject(message, result ->  { <1>
            if (result.getException() != null) {
                System.out.println("Unable to send message: " + result.getException());
            }
        });
    });
}
----
<1> Using `getAsyncRemote().sendObject()` on a session you can send a message to the client


== Vertx and event bus
=== Allgemeines
Für Operationen die länger dauern können(DB Zugriffe, ...) sollte man den Endpunkt asynchron
implementieren um Rechenleistung zu sparen. Dafür wird Vertx verwendet.

Mutiny ist grob gesagt ein Wrapper von Vertx, der das Reaktive Arbeiten in Quarkus vereinfacht.

=== Implementierung

* Extensions einfügen:
[source]
----
./mvnw quarkus:add-extension -Dextensions="vertx,resteasy-mutiny"
----

* Ein Service erstellen:

[source,java]
----
@ApplicationScoped
public class GreetingService {
}
----

* Einen `ManagedExecutor` mittels Dependency Injection einfügen:

[source,java]
----
@Inject
ManagedExecutor executor;
----

* Einen Consumer für das event `greeting` einfügen:

[source,java]
----
@ConsumeEvent("greeting")
public Uni<String> consume(String name) {
    return Uni.createFrom().item(name::toUpperCase).emitOn(executor);
}
----

* Eine Resource einfügen:

[source,java]
----
@Path("/async")
public class EventResource {
}
----

* Einen EventBus mittels Dependency Injection einfügen:

[source,java]
----
@Inject
EventBus bus;
----

* Einen endpoint zum Behandeln des Requests mittels Event Bus einfügen:

[source, java]
----
@GET
@Produces(MediaType.TEXT_PLAIN)
@Path("{name}")
public Uni<String> greeting(@PathParam("name") String name) {
    return bus.<String>request("greeting", name)
            .onItem().transform(Message::body);
}
----

== KeyCloak und Testcontainer

=== Allgemeines

==== Keycloak
Keycloak ist eine Identity und Access Management (IAM) Lösung für zahlreiche Anwendungen.
Die Open-Source Anwendung wird von RedHat entwickelt und ermöglicht zum Beispiel
auch Single-Sign-On.


==== Testcontainers
Testcontainers ist eine Java-Library welche JUnit tests unterstützt und leichtgewichtige
Instanzen von gängigen Datenbanken, Selenium Web Browsern oder allem anderen,
was in einem Docker-Container laufen kann, bereitstellt.
Einsatz vor allem bei Tests, wo man eine Datenbank benötigt.

=== Implementierung

Extension einfügen:

[source, xml]
----
<dependency>
    <groupId>com.github.dasniko</groupId>
    <artifactId>testcontainers-keycloak</artifactId>
    <version>1.6.0</version>
    <scope>test</scope>
</dependency>
----

Keycloak Resource zu tests hinzufügen:
[source, java]
----
public class KeycloakResource implements QuarkusTestResourceLifecycleManager {
    KeycloakContainer keycloak;

    @Override
    public Map<String, String> start() {
        keycloak = new KeycloakContainer()
                .withRealmImportFile("/quarkus-realm.json"); <1>
        keycloak.start();

        return Map.of("quarkus.oidc.auth-server-url", keycloak.getAuthServerUrl() + "/realms/quarkus");
    }

    @Override
    public void stop() {
        if (keycloak != null) {
            keycloak.stop();
        }
    }
}
----
<1> Realm File muss in src/test/resources liegen.

Um bei den Tests den Token einfach zu bekommen, implementiert man einen AccessTokenProvider:

[source,java]
----
package at.htl.keycloak;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import java.util.Map;

import static io.restassured.RestAssured.given;

public abstract class AccessTokenProvider {
    @ConfigProperty(name = "quarkus.oidc.auth-server-url")
    String authServerUrl;
    @ConfigProperty(name = "quarkus.oidc.client-id")
    String clientId;

    protected String getAccessToken(String username, String password) {
        return given().contentType("application/x-www-form-urlencoded")
                .formParams(Map.of(
                        "username", username,
                        "password", password,
                        "grant_type", "password",
                        "client_id", clientId,
                        "client_secret", "secret"
                ))
                .post(authServerUrl + "/protocol/openid-connect/token")
                .then().assertThat().statusCode(200)
                .extract().path("access_token");
    }
}

----

Nun können die Test implementiert werden:
[source,java]
----
@QuarkusTest
@QuarkusTestResource(KeycloakResource.class)<1>
public class UsersResourceTest extends AccessTokenProvider { <2>

    @Test
    public void testMeAnonymous() {
        given().when().get("/users/me").then().statusCode(401);
    }

    @Test
    public void testMeSuccessfully() {
        given()
                .auth().oauth2(getAccessToken("john", "john"))
                .when().get("/users/me")
                .then()
                .statusCode(200)
                .body(allOf(
                        containsString("username"),
                        containsString("john")
                ));
    }

    @Test
    public void testMeAdminSuccessfully() {
        given()
                .auth().oauth2(getAccessToken("admin", "admin"))
                .when().get("/users/me")
                .then()
                .statusCode(200)
                .body(allOf(
                        containsString("username"),
                        containsString("admin")
                ));
    }

    @Test
    public void testInfoEndpoint() {
        given()
                .auth().oauth2(getAccessToken("john", "john"))
                .when().get("/users/info")
                .then()
                .statusCode(200)
                .body(allOf(
                        containsString("email"),
                        containsString("john@localhost")
                ));
    }
}
----

<1> Testklasse mit `@QuarkusTestResource(KeycloakResource.class)` annotieren, damit
eine Keycloak Instanz mittels Docker automatisch gestartet wird, wenn die Tests ausgeführt werden.
<2> Nun erben wir vom AccessTokenProvider um den Token zu bekommen.
