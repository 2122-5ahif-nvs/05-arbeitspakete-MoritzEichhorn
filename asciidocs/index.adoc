= Arbeitspakete Dokumentation
Moritz Eichhorn
1.0.0, 2021-12-09
ifndef::imagesdir[:imagesdir: images]
//:toc-placement!:  // prevents the generation of the doc at this position, so it can be printed afterwards
:sourcedir: ../src/main/java
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc: left

//Need this blank line after ifdef, don't know why...
ifdef::backend-html5[]

// print the toc here (not at the default position)
//toc::

== Websockets
=== Allgemeines
Bei Websockets besteht zwischen dem Server und dem Client eine
bidirektionale Verbindung. So kann auch der Server dem Client
Informationen zukommenlassen.

Beispiele:

* Chat
* Live-Sport-Ticker
* Onlinespiele

=== Implementierung
* Extension einfügen:

[source]
----
./mvnw quarkus:add-extension -Dextensions="websockets"
----

* Neuen Serverendpoint Erstellen:

[source,java]
----
@ServerEndpoint("/chat/{username}")
@ApplicationScoped
public class ChatSocket {
}
----

* Zur Verwaltung der Sessions eine Map erstellen:

[source,java]
----
Map<String, Session> sessions = new ConcurrentHashMap<>();
----

* Methoden für den Umgang mit Websockets in `ChatSocket` einfügen:

[source,java]
----
@OnOpen
public void onOpen(Session session, @PathParam("username") String username) {
    sessions.put(username, session);
}

@OnClose
public void onClose(Session session, @PathParam("username") String username) {
    sessions.remove(username);
    broadcast("User " + username + " left");
}

@OnError
public void onError(Session session, @PathParam("username") String username, Throwable throwable) {
    sessions.remove(username);
    broadcast("User " + username + " left on error: " + throwable);
}

@OnMessage
public void onMessage(String message, @PathParam("username") String username) {
    if (message.equalsIgnoreCase("_ready_")) {
        broadcast("User " + username + " joined");
    } else {
        broadcast(">> " + username + ": " + message);
    }
}

private void broadcast(String message) {
    sessions.values().forEach(s -> {
        s.getAsyncRemote().sendObject(message, result ->  { <1>
            if (result.getException() != null) {
                System.out.println("Unable to send message: " + result.getException());
            }
        });
    });
}
----
<1> Using `getAsyncRemote().sendObject()` on a session you can send a message to the client


== Vertx and event bus
=== Allgemeines
Für Operationen die länger dauern können(DB Zugriffe, ...) sollte man den Endpunkt asynchron
implementieren um Rechenleistung zu sparen. Dafür wird Vertx verwendet.

Mutiny ist grob gesagt ein Wrapper von Vertx, der das Reaktive Arbeiten in Quarkus vereinfacht.

=== Implementierung

* Extensions einfügen:
[source]
----
./mvnw quarkus:add-extension -Dextensions="vertx,resteasy-mutiny"
----

* Ein Service erstellen:

[source,java]
----
@ApplicationScoped
public class GreetingService {
}
----

* Einen `ManagedExecutor` mittels Dependency Injection einfügen:

[source,java]
----
@Inject
ManagedExecutor executor;
----

* Einen Consumer für das event `greeting` einfügen:

[source,java]
----
@ConsumeEvent("greeting")
public Uni<String> consume(String name) {
    return Uni.createFrom().item(name::toUpperCase).emitOn(executor);
}
----

* Eine Resource einfügen:

[source,java]
----
@Path("/async")
public class EventResource {
}
----

* Einen EventBus mittels Dependency Injection einfügen:

[source,java]
----
@Inject
EventBus bus;
----

* Einen endpoint zum Behandeln des Requests mittels Event Bus einfügen:

[source, java]
----
@GET
@Produces(MediaType.TEXT_PLAIN)
@Path("{name}")
public Uni<String> greeting(@PathParam("name") String name) {
    return bus.<String>request("greeting", name)
            .onItem().transform(Message::body);
}
----




